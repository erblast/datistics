---
title: Advanced R notes
author: Björn Koneswarakantha
date: '2020-11-30'
slug: advancedr
categories:
  - Rtraining
tags:
  - R
  - Rtraining
summary: Notes when going through advanced R
thumbnailImagePosition : leftx
thumbnailImage: https://images-na.ssl-images-amazon.com/images/I/41RJLhZ32VL.jpg
editor_options: 
  chunk_output_type: console
output:
  blogdown::html_page:
    toc: true
---

```{r load}
library(tidyverse)
library(rlang)
library(lobstr)
library(withr)
library(glue)
```


# Functions

## Functions to Investigate Functions

```{r}
.f <- function(x,y){
  # Comment
  x + y
}
formals(.f) # returns arguments
body(.f) # returns body without comments
environment(.f) 
attributes(.f)$srcref # returns body with commments
```

## Get all Functions from package

```{r}
objs <- mget(ls("package:base", all = TRUE), inherits = TRUE)
funs <- Filter(is.function, objs)
```

## Function with the most arguments

primitive base functions written in C are either of type "builtin" or "special". `formals()`, `body()`and `environment()` will return NULL for those functions.

```{r}
df_funs <- tibble(funs = funs,
       names = names(funs) ) %>%
  mutate(formals = map(funs, formals),
         n_args = map_int(formals, length),
         type = map_chr(funs, typeof)) %>%
  arrange(desc(n_args))

df_funs

df_funs %>%
  group_by(type, n_args == 0) %>%
  count()
```

## Scoping

### Search Environment

```{r}

my_string <- "hello world"

exists("my_string")
exists("my_string_2")
get0("my_string")
get0("my_string_2")

ls() # get all variable names
```


### List unbound global variables

```{r}
g12 <- function() x + 1
codetools::findGlobals(g12)

g13 <- function(x) x + 1
codetools::findGlobals(g13)
```


### Lazy Evaluation of Arguments

arguments even when given as expressions will only be evaluated when called in the function, these structures are called promises. So this works, surprisingly:

```{r}
h04 <- function(x = 1, y = x * 2, z = a + b) {
  a <- 10
  b <- 100
  
  c(x, y, z)
}

```

But only when supplied as default arguments not when user-supplied

```{r error= TRUE}
h04(1, x * 2, a + b)
```

User-Supplied arguments are evaluated before they are passed to the function, that is why infix functions and operators such as `+` and `%%`are working. 

Default arguments are evaluated as promises only when they are called within the function.

Reminder infix functions take two arguments, code that comes directly before and right after. User defined infix functions need to be defined like this with ``%name%` <- function(lhs, rhs)`

```{r}
x <- 1

!is.null(x) && length(x) == 1 && x > 0

# in python we would need to put brackets around the logic statements
(!is.null(x)) && (length(x) == 1) && (x > 0)


c(TRUE, FALSE) && c(TRUE, FALSE) # evaluation stops at first element
c(TRUE, FALSE) & c(TRUE, FALSE) # all elements are pair-wise evaluated

FALSE && NULL # evaluation stops after result is determined by first argument FALSE
FALSE || NULL # gives error because NULL needs to be evaluated for OR condition
FALSE & NULL # I would expect this to error too
FALSE | NULL # this as well mmh
```



### Default or User Supplied argument

```{r}
h06 <- function(x = 10) {
  is_default <- missing(x)
  return(is_default)
}

h06()
h06(10)
```

### Capture dot dot dot

```{r}
i03 <- function(...) {
  list(first = ..1, third = ..3)
}
str(i03(1, 2, 3))

i04 <- function(...) {
  list(...)
}
str(i04(a = 1, b = 2))
```

### Exit Handler `on.exit()`

Always set add = TRUE when using on.exit(). If you don’t, each call to on.exit() will overwrite the previous exit handler. Even when only registering a single handler, it’s good practice to set add = TRUE so that you won’t get any unpleasant surprises if you later add more exit handlers.

```{r error=TRUE}
j06 <- function(x) {
  cat("Hello\n")
  on.exit(cat("Goodbye!\n"), add = TRUE)
  
  if (x) {
    return(10)
  } else {
    stop("Error")
  }
}

j06(TRUE)

j06(FALSE)
```

Better than using `on.exit` is actually to use functions of the `withr` package that automatically provide cleanups for files and directories

### Capture output `capture.output()`

also captures error messages

### Everything that happens in R is a function call

Almost everything can be rewritten as a function call

```{r}
x + y
`+`(x, y)

names(df) <- c("x", "y", "z")
`names<-`(df, c("x", "y", "z"))

for(i in 1:10) print(i)
`for`(i, 1:10, print(i))
```


### Replacement Functions

```{r}
`second<-` <- function(x, value) {
  x[2] <- value
  x
}

x <- 1:10
second(x) <- 5

x
```

## Environments

Generally, an environment is similar to a named list, with four important exceptions:

- Every name must be unique.
- The names in an environment are not ordered.
- An environment has a parent.
- Environments are not copied when modified.

```{r}
e1 <- env(
  a = FALSE,
  b = "a",
  c = 2.3,
  d = 1:3,
)

rlang::env_print(e1)
rlang::env_names(e1)

```

### Create a parent environment

```{r}
e2 <- env(e1, letters = LETTERS)

rlang::env_parent(e2)
rlang::env_parents(e2)
```

### Packages

Composition of the global environment

```{r}
search()
rlang::search_envs()
```

### Package Functions
- passively bound by one environment (where they can be called from)
- actively bind one environment (which they use to make their calls)

for regular functions both environments are the same. For functions loaded from packages the bind environment is defined by the package namespace created from the package NAMESPACE file. Like this they are not affected by overrides in the execution environment.

### Closures

```{r}

storer <- function(){
  store_var <- 5
  function() store_var
}

storage <- storer()
storage()

exists("store_var", envir = rlang::current_env())
exists("store_var", envir = environment(storage))


make_counter <- function(){
  count_var <- 0
  function() {
    count_var <<- count_var + 1 # <<- passes the assignment to parent environment where it is preserved via the binding
    count_var
  }
}

counter <- make_counter()

exists("count_var", envir = rlang::current_env())
exists("count_var", envir = environment(counter))

counter()
counter()
counter()
counter()

```


### Callstacks

use `lobstr::cst()` in a similar way to `traceback()` to visualise the callstack.

```{r error=TRUE}
f <- function(x) {
  g(x = 2)
}
g <- function(x) {
  h(x = 3)
}
h <- function(x) {
  stop()
}

f(x = 1)

traceback()

h <- function(x) {
  lobstr::cst()
  print("do I get executed =")
}

f(x = 1)
```


## Conditions

### Warnings


```{r error=TRUE}
give_warning <- function() {
  warning("You have been warned")
}

withr::with_options(list(warn = 1), give_warning()) # causes warning to appear immediately
withr::with_options(list(warn = 2), give_warning()) # convert warning to error

```

### Custom Errors

```{r}
check_var_class <- function(..., cl){
  if(! cl %in% class(...)){
    instead <- class(...)
    rlang::abort(
      message = glue::glue("Argument should be of class {cl}. Instead got {instead}"),
      type = "check_class"
    )
  }
}

check_var_zero <- function(...){
  if(... == 0){
    rlang::abort(
      message = "Argument must not be zero",
      type = "check_zero"
    )
  }
}

divide <- function(x,y){
  # catch error division by zero and return Inf
  # this is actually redundant because that is R default
  is_zero_cnd <- rlang::catch_cnd(check_var_zero(y))
  if("type") {
    return(Inf)
  }else{
    is_zero_cnd$trace
    stop(is_zero_cnd$message)
  }
  
  check_var_class(x, cl = "numeric")
  check_var_class(y, cl = "numeric")
  
  return(x/y)
}

divide(1,2)
divide("1", 2)
divide(1, 0)
divide(1,)
```

